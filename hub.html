<!-- Save as: hub.html -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Hub — grid + cards</title>
<style>
/* Hub base styles */
:root{--bg:#0c0f12;--card-w:180px;--card-h:260px}
html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;background:var(--bg);color:#fff}
body{display:grid;place-items:center;overflow:hidden}
.page{min-height:100vh;display:grid;place-items:center;position:relative;width:100%;height:100%}

/* Title and layout */
.center-col{display:flex;flex-direction:column;align-items:center;gap:18px;z-index:3;pointer-events:auto}
.title{font-weight:700;font-size:3rem;margin:0}
.controls{display:flex;align-items:center;gap:12px}
.mode-switch{display:flex;gap:12px}
.mode-btn{width:48px;height:48px;border-radius:50%;border:2px solid #fff;background:#fb7575;display:grid;place-items:center;cursor:pointer}
.cta-purple{display:flex;align-items:center;gap:8px;padding:8px 12px;border-radius:10px;background:#9146FF;color:#fff;border:none;cursor:pointer}

/* Grid canvas sits behind everything */
.grid-trail{position:fixed;inset:0;z-index:0;display:block;width:100vw;height:100vh;pointer-events:auto}

/* Cards host sits visually above the grid, but mostly non-interactive so underlying grid remains interactive */
.cards-host-wrapper{position:relative;display:grid;place-items:center;z-index:2;pointer-events:none; /* important: allow clicks to pass through except where elements explicitly allow them */}

/* The host that holds the cards stage. We size it to the stage bounding box dynamically */
.cards-host{position:relative;display:inline-block;overflow:visible;background:transparent;border-radius:8px;pointer-events:none;}

/* Scoped card styles — we copy the necessary card CSS but scope under .cards-host so it does not affect the rest of the hub */
.cards-host .stage{position:relative;display:grid;place-items:center;min-height:var(--card-h);cursor:grab;transform:translateY(var(--center-offset));perspective:900px;transform-style:preserve-3d;pointer-events:auto} /* enable interaction on stage itself */
.cards-host .card{position:absolute;width:var(--card-w);height:var(--card-h);border-radius:18px;overflow:hidden;background:#111;box-shadow:0 12px 30px rgba(0,0,0,.45);transition:transform .35s ease, filter .35s ease, opacity .35s ease, outline-color .18s ease, outline-width .18s ease;pointer-events:auto}
.cards-host .card::before{content:"";position:absolute;top:0;left:0;right:0;height:2px;background:linear-gradient(90deg,transparent,#7ec8ff,transparent);animation:scanline 3s linear infinite;pointer-events:none;box-shadow:0 0 10px rgba(126,200,255,.5)}
.cards-host .card::after{content:"";position:absolute;inset:auto 0 0 0;height:40%;background:linear-gradient(to top,rgba(0,0,0,.7),rgba(0,0,0,0));pointer-events:none;transform:translateY(20px)}
.cards-host .bg{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;pointer-events:none}
.cards-host .avatar{position:absolute;left:50%;bottom:0;transform:translateX(-50%);width:72%;height:auto;object-fit:contain;pointer-events:none}
.cards-host .text{position:absolute;left:16px;bottom:16px;display:flex;flex-direction:column;gap:4px;z-index:2}
.cards-host .name{font-weight:700;font-size:1.15rem}
.cards-host .handle{opacity:.7;font-size:.95rem}

/* small prev/next */
.cards-host .card.prev,.cards-host .card.next{width:calc(var(--card-w)*0.7);height:calc(var(--card-h)*0.7);filter:blur(2px);pointer-events:none}
.cards-host .card.prev{opacity:.85;transform:translateX(calc(-1 * var(--card-w) * 0.72)) rotateZ(-60deg)}
.cards-host .card.next{opacity:.85;transform:translateX(calc(var(--card-w) * 0.72)) rotateZ(60deg)}

.cards-host .arrow{position:absolute;top:50%;transform:translateY(-50%);background:rgba(255,255,255,.12);color:#fff;border:none;border-radius:999px;width:clamp(32px, calc(var(--card-w)*0.14), 56px);height:clamp(32px, calc(var(--card-w)*0.14), 56px);display:grid;place-items:center;backdrop-filter:blur(6px);cursor:pointer;z-index:4;font-size:clamp(20px, calc(var(--card-w)*0.08), 32px);user-select:none;pointer-events:auto}
.cards-host .arrow.left{left:calc(50% - calc(var(--card-w)*1.5))}
.cards-host .arrow.right{left:calc(50% + calc(var(--card-w)*1.5))}
.cards-host .arrow:hover{background:rgba(255,255,255,.18)}

/* tracker bubble area, interaction allowed */
.cards-host .ui-stack{position:relative;display:flex;flex-direction:column;align-items:center;gap:20px;margin-top:calc(var(--card-h)/2 + 20px);pointer-events:auto}
.cards-host .tracker{display:flex;gap:10px;justify-content:center}
.cards-host .bubble-slot{position:relative;width:13px;height:13px;display:grid;place-items:center}
.cards-host .bubble{background:rgba(255,255,255,.35);height:13px;width:13px;border-radius:50%}

/* ensure nothing visual from host obstructs page layout */
.cards-host, .cards-host *{background-clip:padding-box}

/* make sure the whole cards host does not grab pointer events (so grid remains interactive) except explicit elements above already set to pointer-events:auto */
.cards-host-wrapper{pointer-events:none}
.cards-host{pointer-events:none}
.cards-host .stage, .cards-host .card, .cards-host .arrow, .cards-host .ui-stack {pointer-events:auto}

/* make the host visually seamless */
.cards-host{background:transparent}

/* small responsive */
@media (max-width:768px){:root{--card-w:68vw;--card-h:calc(68vw*1.35)}}
@media (max-width:420px){:root{--card-w:74vw;--card-h:calc(74vw*1.35)}}

/* grid canvas custom style */
.grid-trail{position:fixed;inset:0;z-index:0;display:block;pointer-events:auto}
</style>
</head>
<body>
  <canvas id="grid-trail" class="grid-trail"></canvas>

  <div class="page">
    <div class="center-col">
      <h1 class="title">About Us</h1>

      <!-- CARDS HOST: this is the container that will hold the cards stage -->
      <div class="cards-host-wrapper" id="cards-host-wrapper" aria-hidden="false">
        <div class="cards-host" id="cards-host" role="region" aria-label="Cards area">
          <!-- We include the cards markup directly. This duplicates the files slightly but avoids cross-origin and iframe pointer issues -->
          <div class="stage" id="stage">
            <div class="card prev" id="card-prev">
              <img class="bg" alt="background" draggable="false" />
              <img class="avatar" alt="avatar" draggable="false" />
              <div class="text">
                <div class="name"></div>
                <div class="handle"></div>
              </div>
            </div>

            <div class="card main" id="card-main">
              <img class="bg" alt="background" draggable="false" />
              <img class="avatar" alt="avatar" draggable="false" />
              <div class="text">
                <div class="name"></div>
                <div class="handle"></div>
              </div>
            </div>

            <div class="card next" id="card-next">
              <img class="bg" alt="background" draggable="false" />
              <img class="avatar" alt="avatar" draggable="false" />
              <div class="text">
                <div class="name"></div>
                <div class="handle"></div>
              </div>
            </div>

            <div class="card preload" id="card-preload">
              <img class="bg" alt="background" draggable="false" />
              <img class="avatar" alt="avatar" draggable="false" />
              <div class="text">
                <div class="name"></div>
                <div class="handle"></div>
              </div>
            </div>

            <button class="arrow left" id="arrow-left" aria-label="Previous">&#x2039;</button>
            <button class="arrow right" id="arrow-right" aria-label="Next">&#x203A;</button>

            <div class="ui-stack" id="ui-stack">
              <div class="tracker" id="tracker"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="controls">
        <div class="mode-switch" role="tablist" aria-label="Display mode">
          <button class="mode-btn" id="mode-revolve" aria-pressed="true">R</button>
          <button class="mode-btn" id="mode-list" aria-pressed="false">L</button>
        </div>
        <button class="cta-purple" id="cta-purple"><span id="cta-handle">@twitch</span></button>
      </div>
    </div>
  </div>

<script>
/* --- Grid trail code (same logic as original initGridTrail) --- */
function initGridTrail(opts){
  const settings=Object.assign({ spacing:28, amplitude:36, trailLen:28, maxDPR:1.5, maxNodes:2200, canvas: null }, opts||{});
  const canvas = settings.canvas || document.getElementById('grid-trail');
  if(!canvas) return { destroy(){} };
  const ctx = canvas.getContext('2d');
  let DPR = Math.min(settings.maxDPR, Math.max(1, window.devicePixelRatio || 1));
  let nodes = [];
  const mouse = { x: 0, y: 0, down:false };
  const trail = [];
  let rid = null;
  let lastTime = performance.now();

  function resize(){
    DPR = Math.min(settings.maxDPR, Math.max(1, window.devicePixelRatio || 1));
    const w = Math.max(1, innerWidth);
    const h = Math.max(1, innerHeight);
    canvas.width = Math.floor(w * DPR);
    canvas.height = Math.floor(h * DPR);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
    rebuildGrid();
  }

  function pushTrail(x,y){ trail.push({x,y,t:performance.now()}); if(trail.length > settings.trailLen) trail.shift(); }

  function rebuildGrid(){
    const spacing = settings.spacing;
    nodes = [];
    const w = Math.max(1, innerWidth);
    const h = Math.max(1, innerHeight);
    const cols = Math.ceil(w/spacing) + 1;
    const rows = Math.ceil(h/spacing) + 1;
    const total = cols*rows;
    const cap = Math.max(1, settings.maxNodes);
    for (let j=0;j<rows && nodes.length<cap;j++){
      for (let i=0;i<cols && nodes.length<cap;i++){
        const x = i*spacing - (w%spacing)/2;
        const y = j*spacing - (h%spacing)/2;
        nodes.push({x,y,ox:x,oy:y,vx:0,vy:0,phase:Math.random()*Math.PI*2});
      }
    }
  }

  function update(dt, t){
    const amp = settings.amplitude;
    for (let n of nodes){
      let influence = 0;
      for (let k = Math.max(0, trail.length - 6); k < trail.length; k++){
        const p = trail[k];
        const dx = n.ox - p.x;
        const dy = n.oy - p.y;
        const d2 = dx*dx + dy*dy;
        const fall = Math.exp(-d2 / (amp * amp * 6));
        influence = Math.max(influence, fall);
      }
      const wobble = 0.8 + Math.sin(t / 300 + n.phase) * 0.4;
      const targetY = n.oy - influence * amp * wobble;
      const k_spring = 10;
      const k_damp = 0.85;
      n.vy += (targetY - (n.y || n.oy)) * k_spring * dt;
      n.vy *= Math.pow(k_damp, dt * 60);
      n.y = (n.y || n.oy) + n.vy * dt * 60;
    }
  }

  function draw(){
    const w = Math.max(1, innerWidth); const h = Math.max(1, innerHeight);
    ctx.clearRect(0,0,w,h);
    const spacing = settings.spacing;
    const colsPerRow = Math.ceil(w / spacing) + 1;
    ctx.lineWidth = 1;
    for (let j = 0; j * colsPerRow < nodes.length; j++){
      const rowStart = j * colsPerRow;
      ctx.beginPath();
      for (let i = 0; i < colsPerRow; i++){
        const idx = rowStart + i;
        if (idx >= nodes.length) break;
        const n = nodes[idx];
        if (i === 0) ctx.moveTo(n.x, n.y || n.oy);
        else ctx.lineTo(n.x, n.y || n.oy);
      }
      let rowAvg = 0; let count = 0;
      for (let i = 0; i < colsPerRow; i++){
        const idx = rowStart + i; if (idx >= nodes.length) break;
        const n = nodes[idx]; rowAvg += Math.abs((n.y || n.oy) - n.oy); count++;
      }
      rowAvg = count ? rowAvg / count : 0;
      const alpha = Math.min(1, 0.25 + rowAvg / (settings.amplitude * 2));
      ctx.strokeStyle = `rgba(160,210,255,${alpha})`;
      ctx.stroke();
    }
    for (let n of nodes){
      const ny = n.y || n.oy;
      const off = ny - n.oy;
      const r = Math.max(0.8, Math.abs(off) / 8 + 0.8);
      const a = Math.min(1, Math.abs(off) / (settings.amplitude * 1.2) + 0.15);
      ctx.beginPath();
      ctx.arc(n.x, ny, r, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(140,200,255,${a})`;
      ctx.fill();
    }
    ctx.beginPath();
    ctx.arc(mouse.x, mouse.y, 12, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(120,200,255,0.06)';
    ctx.fill();
  }

  function frame(t){
    const dt = Math.min(40, t - lastTime) / 1000;
    lastTime = t;
    update(dt, t);
    draw();
    rid = requestAnimationFrame(frame);
  }

  function onMove(e){ mouse.x = e.clientX; mouse.y = e.clientY; if(mouse.down) pushTrail(mouse.x, mouse.y); }
  function onDown(e){ mouse.down = true; pushTrail(e.clientX, e.clientY); }
  function onUp(){ mouse.down = false; }

  window.addEventListener('resize', resize);
  document.addEventListener('pointermove', onMove, { passive:true });
  document.addEventListener('pointerdown', onDown, { passive:true });
  document.addEventListener('pointerup', onUp, { passive:true });

  // seed trail
  { const w = Math.max(1, innerWidth); const h = Math.max(1, innerHeight); for (let i = 0; i < 10; i++) trail.push({x: w / 2, y: h / 2, t: performance.now() - i * 20}); }

  resize();
  rid = requestAnimationFrame(frame);

  return {
    destroy(){
      try{ cancelAnimationFrame(rid); }catch{}
      window.removeEventListener('resize', resize);
      document.removeEventListener('pointermove', onMove);
      document.removeEventListener('pointerdown', onDown);
      document.removeEventListener('pointerup', onUp);
      nodes = []; trail.length = 0;
      ctx.clearRect(0,0,canvas.width,canvas.height);
    },
    set(newOpts){ Object.assign(settings, newOpts||{}); rebuildGrid(); },
    get(){ return Object.assign({}, settings); }
  };
}

/* init the grid */
window._gridTrail = initGridTrail({
  canvas: document.getElementById('grid-trail'),
  spacing: 28,
  amplitude: 36,
  trailLen: 28,
  maxDPR: 1.5,
  maxNodes: 2200
});

/* --- Cards logic: copied and adapted so it mounts into the host area in the hub --- */

let characters = [
  { id:'a1', name:'Alice', handle:'@alice', bg:'', avatar:'' },
  { id:'b2', name:'Bob', handle:'@bob', bg:'', avatar:'' },
  { id:'c3', name:'Celia', handle:'@celia', bg:'', avatar:'' }
];
let currentIndex = 0;
let isCardAnimating = false;
let isBubbleAnimating = false;
let bubbleState = { glowSlot:'b' };
let settings = { switchAnimation:true, animationSpeedPercent:100 };

/* reuse apply & render functions (same as cards.html) */
function apply(cardEl, character){
  const bg=(character.bg&&character.bg.trim())?character.bg:'';
  const bgEl = cardEl.querySelector('.bg');
  if(bgEl){ bgEl.src = bg || ''; }
  const av = cardEl.querySelector('.avatar');
  if(av){ av.src = (character.avatar && character.avatar.trim()) ? character.avatar : './assets/phavatar.png'; }
  cardEl.querySelector('.name').textContent = character.name || '';
  cardEl.querySelector('.handle').textContent = character.handle || '';
}

function render(){
  const main=document.getElementById('card-main');
  const prev=document.getElementById('card-prev');
  const next=document.getElementById('card-next');
  const preload=document.getElementById('card-preload');
  const n=characters.length;
  const i=currentIndex;
  const p=(i-1+n)%n;
  const q=(i+1)%n;
  const r=(i+2)%n;
  apply(main,characters[i]);
  apply(prev,characters[p]);
  apply(next,characters[q]);
  if(preload){apply(preload,characters[r])}
  if(!isBubbleAnimating){ renderBubbles(); }
}

/* bubbles */
function renderBubbles(){
  const el=document.getElementById('tracker');
  if(!el) return;
  el.innerHTML='';
  const slots=['a','b','c'];
  slots.forEach(slot=>{
    const slotEl=document.createElement('div');
    slotEl.className=`bubble-slot slot-${slot}`;
    const bubble=document.createElement('div');
    bubble.className='bubble';
    bubble.setAttribute('data-slot',slot);
    slotEl.appendChild(bubble);
    el.appendChild(slotEl);
  });
  const n=characters.length; const i=currentIndex;
  bubbleState.glowSlot = i===0 ? 'a' : (i===n-1 ? 'c' : 'b');
  ensureGlow();
}
function ensureGlow(){
  const el=document.getElementById('tracker');
  const glowExisting=el.querySelector('.bubble-glow');
  const targetSlot=el.querySelector(`.bubble-slot.slot-${bubbleState.glowSlot} .bubble`);
  if(!targetSlot) return;
  if(!glowExisting){
    const glow=document.createElement('div');
    glow.className='bubble-glow';
    targetSlot.appendChild(glow);
  }else{
    glowExisting.parentNode&&glowExisting.parentNode.removeChild(glowExisting);
    targetSlot.appendChild(glowExisting);
  }
}

/* navigation — same timing profile as original */
function navigate(direction){
  if(isCardAnimating||isBubbleAnimating) return;
  const dir = direction === 'left' ? 1 : -1;
  if(!settings.switchAnimation){
    currentIndex = (currentIndex + dir + characters.length) % characters.length;
    render(); adjustHostSize(); return;
  }
  const s=document.querySelector('.stage');
  isCardAnimating=true;
  s.classList.remove('anim-left','anim-right','preload-left','preload-right','size-left','size-right','move-left','move-right','phase1','phase2');
  s.classList.add(direction==='left'?'preload-right':'preload-left');
  s.classList.add('phase1');
  s.offsetHeight;
  s.classList.add(direction==='left'?'size-left':'size-right');
  const scale=100/settings.animationSpeedPercent; const gapMs=Math.round(140*scale); const moveMs=Math.round(360*scale);
  setTimeout(()=>{
    s.classList.remove('phase1');
    s.classList.add('phase2');
    s.classList.add(direction==='left'?'move-left':'move-right');
    setTimeout(()=>{
      currentIndex = (currentIndex + dir + characters.length) % characters.length;
      s.classList.remove('phase2','size-left','size-right','move-left','move-right','preload-left','preload-right');
      s.classList.add('finalize');
      render();
      const main=document.getElementById('card-main');
      if(main){main.classList.add('settle');setTimeout(()=>{main.classList.remove('settle')},Math.round(220*(100/settings.animationSpeedPercent)))}
      s.offsetHeight;
      s.classList.remove('finalize');
      isCardAnimating=false;
      adjustHostSize();
    },moveMs);
  },gapMs);
}

/* simple arrow bindings and interaction rules */
document.addEventListener('DOMContentLoaded',()=>{
  render();
  document.getElementById('arrow-left').addEventListener('click',()=>navigate('right'));
  document.getElementById('arrow-right').addEventListener('click',()=>navigate('left'));
  // stage click: only navigate if clicking into the visible card area between title and controls; since host is centred, simple guard
  const stage = document.querySelector('.stage');
  stage.addEventListener('click',(e)=>{
    // allow clicking cards to open sheet or trigger nav
    if(e.target.closest('.card')) return;
    const rect = stage.getBoundingClientRect();
    const mid = rect.left + rect.width/2;
    if(e.clientX < mid) navigate('right'); else navigate('left');
  });

  // initial host size adjust
  adjustHostSize();
  // recompute on resize
  window.addEventListener('resize', debounce(adjustHostSize, 80));
});

/* measure stage and ensure the .cards-host wrapper exactly fits the interactive area so no extra whitespace or scrollbars */
function adjustHostSize(){
  const hostWrapper = document.getElementById('cards-host-wrapper');
  const host = document.getElementById('cards-host');
  const stage = host.querySelector('.stage');
  if(!stage || !host || !hostWrapper) return;
  // compute stage bounding including arrows
  const rect = stage.getBoundingClientRect();
  // arrows may extend beyond stage; explicitly measure arrows
  const leftArrow = stage.querySelector('.arrow.left');
  const rightArrow = stage.querySelector('.arrow.right');
  const leftRect = leftArrow ? leftArrow.getBoundingClientRect() : rect;
  const rightRect = rightArrow ? rightArrow.getBoundingClientRect() : rect;
  const minLeft = Math.min(rect.left, leftRect.left);
  const maxRight = Math.max(rect.right, rightRect.right);
  const width = Math.ceil(maxRight - minLeft);
  const top = Math.floor(Math.min(rect.top, leftRect.top, rightRect.top));
  const bottom = Math.ceil(Math.max(rect.bottom, leftRect.bottom, rightRect.bottom));
  const height = bottom - top;
  // set inline styles to host so it tightly wraps the cards area
  host.style.width = width + 'px';
  host.style.height = height + 'px';
  host.style.display = 'inline-block';
  // center host (wrapper already centres using flex/grid)
}

/* small debounce util */
function debounce(fn, ms){ let tid=null; return function(){ clearTimeout(tid); tid = setTimeout(()=>fn.apply(this, arguments), ms); }; }

/* ensure arrow/key/swipe gestures still work (basic swipe) */
(function setupSwipe(){
  const s=document.querySelector('.stage');
  let startX=0,startT=0,isDragging=false,dragThreshold=10;
  function pd(e){
    // Only start dragging if pointer inside main card area
    const target=e.target;
    const mainCard = document.getElementById('card-main');
    if(!mainCard.contains(target) && !target.closest('.arrow')) return;
    startX=(e.touches?e.touches[0].clientX:e.clientX);
    startT=performance.now();
    isDragging=false;
    s.classList.add('dragging');
  }
  function pm(e){
    if(startX===0) return;
    const currentX=(e.touches?e.touches[0].clientX:e.clientX);
    const dx=currentX-startX;
    if(Math.abs(dx) > dragThreshold) isDragging=true;
  }
  function pu(e){
    if(startX===0) return;
    const endX=(e.changedTouches&&e.changedTouches[0]?e.changedTouches[0].clientX:e.clientX);
    const dx=(endX||startX)-startX;
    const dt=Math.max(1,performance.now()-startT);
    const v=dx/dt;
    s.classList.remove('dragging');
    if(isDragging){
      if(v<-0.6||dx<-60){navigate('left')}
      else if(v>0.6||dx>60){navigate('right')}
    }
    startX=0; isDragging=false;
  }
  s.addEventListener('pointerdown',pd,{passive:true});
  window.addEventListener('pointermove',pm,{passive:true});
  window.addEventListener('pointerup',pu,{passive:true});
  s.addEventListener('touchstart',pd,{passive:true});
  window.addEventListener('touchmove',pm,{passive:true});
  window.addEventListener('touchend',pu,{passive:true});
})();

/* Expose simple API so you can programmatically set characters from the hub console */
window.cardHost = {
  setCharacters(arr){ if(Array.isArray(arr)){ characters = arr; currentIndex = 0; render(); adjustHostSize(); } },
  go(i){ if(typeof i==='number'){ currentIndex = i; render(); adjustHostSize(); } }
};
</script>
</body>
</html>
